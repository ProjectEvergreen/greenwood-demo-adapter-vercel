diff --git a/node_modules/@greenwood/cli/src/config/rollup.config.js b/node_modules/@greenwood/cli/src/config/rollup.config.js
index 8aa6f56..0292296 100644
--- a/node_modules/@greenwood/cli/src/config/rollup.config.js
+++ b/node_modules/@greenwood/cli/src/config/rollup.config.js
@@ -1,3 +1,4 @@
+/* eslint-disable complexity */
 import fs from 'fs';
 import path from 'path';
 import { checkResourceExists, normalizePathnameForWindows } from '../lib/resource-utils.js';
@@ -140,7 +141,8 @@ function greenwoodSyncPageResourceBundlesPlugin(compilation) {
 }
 
 function getMetaImportPath(node) {
-  return node.arguments[0].value.split('/').join(path.sep);
+  return node.arguments[0].value.split('/').join(path.sep)
+    .replace(/\\/g, '/'); // handle Windows style paths
 }
 
 function isNewUrlImportMetaUrl(node) {
@@ -254,43 +256,63 @@ function greenwoodImportMetaUrl(compilation) {
           ? { type, id: normalizePathnameForWindows(url), name }
           : { type, name: assetName, source: assetContents };
         const ref = this.emitFile(emitConfig);
-        // handle Windows style paths
-        const normalizedRelativeAssetPath = relativeAssetPath.replace(/\\/g, '/');
         const importRef = `import.meta.ROLLUP_FILE_URL_${ref}`;
 
+        // loop through all URL bundle chunks from APIs and SSR pages
+        // and map to their parent file, to pick back up in generateBundle when full hashes are known
+        if (id.indexOf(compilation.context.apisDir.pathname) === 0) {
+          for (const entry of compilation.manifest.apis.keys()) {
+            const apiRoute = compilation.manifest.apis.get(entry);
+
+            if (id.endsWith(apiRoute.path)) {
+              const assets = apiRoute.assets || [];
+
+              assets.push(assetUrl.url.pathname);
+
+              compilation.manifest.apis.set(entry, {
+                ...apiRoute,
+                assets
+              });
+            }
+          }
+        } else {
+          // TODO figure out how to handle URL chunk from SSR pages
+          // https://github.com/ProjectEvergreen/greenwood/issues/1163
+        }
+
         modifiedCode = code
-          .replace(`'${normalizedRelativeAssetPath}'`, importRef)
-          .replace(`"${normalizedRelativeAssetPath}"`, importRef);
+          .replace(`'${relativeAssetPath}'`, importRef)
+          .replace(`"${relativeAssetPath}"`, importRef);
       }
 
       return {
         code: modifiedCode ? modifiedCode : code,
         map: null
       };
-    }
-  };
-}
+    },
 
-// TODO could we use this instead?
-// https://github.com/rollup/rollup/blob/v2.79.1/docs/05-plugin-development.md#resolveimportmeta
-// https://github.com/ProjectEvergreen/greenwood/issues/1087
-function greenwoodPatchSsrPagesEntryPointRuntimeImport() {
-  return {
-    name: 'greenwood-patch-ssr-pages-entry-point-runtime-import',
-    generateBundle(options, bundle) {
-      Object.keys(bundle).forEach((key) => {
-        if (key.startsWith('__')) {
-          // ___GWD_ENTRY_FILE_URL=${filename}___
-          const needle = bundle[key].code.match(/___GWD_ENTRY_FILE_URL=(.*.)___/);
-          if (needle) {
-            const entryPathMatch = needle[1];
-
-            bundle[key].code = bundle[key].code.replace(/'___GWD_ENTRY_FILE_URL=(.*.)___'/, `new URL('./_${entryPathMatch}', import.meta.url)`);
-          } else {
-            console.warn(`Could not find entry path match for bundle => ${key}`);
+    generateBundle(options, bundles) {
+      for (const bundle in bundles) {
+        const bundleExtension = bundle.split('.').pop();
+        const apiKey = `/api/${bundle.replace(`.${bundleExtension}`, '')}`;
+
+        if (compilation.manifest.apis.has(apiKey)) {
+          const apiManifestDetails = compilation.manifest.apis.get(apiKey);
+
+          for (const reference of bundles[bundle].referencedFiles) {
+            if (bundles[reference]) {
+              const assets = apiManifestDetails.assets;
+              const assetIdx = assets.indexOf(bundles[reference].facadeModuleId);
+
+              assets[assetIdx] = new URL(`./api/${reference}`, compilation.context.outputDir).href;
+              compilation.manifest.apis.set(apiKey, {
+                ...apiManifestDetails,
+                assets
+              });
+            }
           }
         }
-      });
+      }
     }
   };
 }
@@ -355,44 +377,35 @@ const getRollupConfigForScriptResources = async (compilation) => {
 
 const getRollupConfigForApis = async (compilation) => {
   const { outputDir, userWorkspace } = compilation.context;
-  const input = [...compilation.manifest.apis.values()]
-    .map(api => normalizePathnameForWindows(new URL(`.${api.path}`, userWorkspace)));
-
-  // why is this needed?
-  await fs.promises.mkdir(new URL('./api/assets/', outputDir), {
-    recursive: true
-  });
 
-  // TODO should routes and APIs have chunks?
-  // https://github.com/ProjectEvergreen/greenwood/issues/1118
-  return [{
-    input,
-    output: {
-      dir: `${normalizePathnameForWindows(outputDir)}/api`,
-      entryFileNames: '[name].js',
-      chunkFileNames: '[name].[hash].js'
-    },
-    plugins: [
-      greenwoodJsonLoader(),
-      greenwoodResourceLoader(compilation),
-      nodeResolve(),
-      commonjs(),
-      greenwoodImportMetaUrl(compilation)
-    ]
-  }];
+  return [...compilation.manifest.apis.values()]
+    .map(api => normalizePathnameForWindows(new URL(`.${api.path}`, userWorkspace)))
+    .map(filepath => ({
+      input: filepath,
+      output: {
+        dir: `${normalizePathnameForWindows(outputDir)}/api`,
+        entryFileNames: '[name].js',
+        chunkFileNames: '[name].[hash].js'
+      },
+      plugins: [
+        greenwoodJsonLoader(),
+        greenwoodResourceLoader(compilation),
+        nodeResolve(),
+        commonjs(),
+        greenwoodImportMetaUrl(compilation)
+      ]
+    }));
 };
 
 const getRollupConfigForSsr = async (compilation, input) => {
   const { outputDir } = compilation.context;
 
-  // TODO should routes and APIs have chunks?
-  // https://github.com/ProjectEvergreen/greenwood/issues/1118
-  return [{
-    input,
+  return input.map(filepath => ({
+    input: filepath,
     output: {
       dir: normalizePathnameForWindows(outputDir),
-      entryFileNames: '_[name].js',
-      chunkFileNames: '[name].[hash].js'
+      entryFileNames: '[name].route.js',
+      chunkFileNames: '[name].route.chunk.[hash].js'
     },
     plugins: [
       greenwoodJsonLoader(),
@@ -404,8 +417,7 @@ const getRollupConfigForSsr = async (compilation, input) => {
         preferBuiltins: true
       }),
       commonjs(),
-      greenwoodImportMetaUrl(compilation),
-      greenwoodPatchSsrPagesEntryPointRuntimeImport() // TODO a little hacky but works for now
+      greenwoodImportMetaUrl(compilation)
     ],
     onwarn: (errorObj) => {
       const { code, message } = errorObj;
@@ -425,7 +437,7 @@ const getRollupConfigForSsr = async (compilation, input) => {
 
       }
     }
-  }];
+  }));
 };
 
 export {
diff --git a/node_modules/@greenwood/cli/src/lifecycles/bundle.js b/node_modules/@greenwood/cli/src/lifecycles/bundle.js
index e5a28fd..154d233 100644
--- a/node_modules/@greenwood/cli/src/lifecycles/bundle.js
+++ b/node_modules/@greenwood/cli/src/lifecycles/bundle.js
@@ -163,11 +163,15 @@ async function bundleStyleResources(compilation, resourcePlugins) {
 
 async function bundleApiRoutes(compilation) {
   // https://rollupjs.org/guide/en/#differences-to-the-javascript-api
-  const [rollupConfig] = await getRollupConfigForApis(compilation);
+  const apiConfigs = await getRollupConfigForApis(compilation);
 
-  if (rollupConfig.input.length !== 0) {
-    const bundle = await rollup(rollupConfig);
-    await bundle.write(rollupConfig.output);
+  if (apiConfigs.length > 0 && apiConfigs[0].input.length !== 0) {
+    for (const configIndex in apiConfigs) {
+      const rollupConfig = apiConfigs[configIndex];
+      const bundle = await rollup(rollupConfig);
+      await bundle.write(rollupConfig.output);
+
+    }
   }
 }
 
@@ -191,12 +195,14 @@ async function bundleSsrPages(compilation) {
     for (const page of compilation.graph) {
       if (page.isSSR && !page.prerender) {
         const { filename, imports, route, template, title } = page;
-        const entryFileUrl = new URL(`./_${filename}`, scratchDir);
+        const entryFileUrl = new URL(`./${filename}`, scratchDir);
         const moduleUrl = new URL(`./${filename}`, pagesDir);
         const request = new Request(moduleUrl); // TODO not really sure how to best no-op this?
         // TODO getTemplate has to be static (for now?)
         // https://github.com/ProjectEvergreen/greenwood/issues/955
         const data = await executeRouteModule({ moduleUrl, compilation, page, prerender: false, htmlContents: null, scripts: [], request });
+        const pagesPathDiff = compilation.context.pagesDir.pathname.replace(compilation.context.projectDirectory.pathname, '');
+
         let staticHtml = '';
 
         staticHtml = data.template ? data.template : await getPageTemplate(staticHtml, compilation.context, template, []);
@@ -206,13 +212,15 @@ async function bundleSsrPages(compilation) {
         staticHtml = staticHtml.replace(/[`\\$]/g, '\\$&'); // https://stackoverflow.com/a/75688937/417806
 
         // better way to write out this inline code?
+        // using a URL here produces a bundled chunk, but at leasts its bundled
         await fs.writeFile(entryFileUrl, `
           import { executeRouteModule } from '${normalizePathnameForWindows(executeModuleUrl)}';
 
+          const moduleUrl = new URL('../${pagesPathDiff}${filename}', import.meta.url);
+
           export async function handler(request) {
             const compilation = JSON.parse('${JSON.stringify(compilation)}');
             const page = JSON.parse('${JSON.stringify(page)}');
-            const moduleUrl = '___GWD_ENTRY_FILE_URL=${filename}___';
             const data = await executeRouteModule({ moduleUrl, compilation, page, request });
             let staticHtml = \`${staticHtml}\`;
 
@@ -228,16 +236,18 @@ async function bundleSsrPages(compilation) {
           }
         `);
 
-        input.push(normalizePathnameForWindows(moduleUrl));
         input.push(normalizePathnameForWindows(entryFileUrl));
       }
     }
 
-    const [rollupConfig] = await getRollupConfigForSsr(compilation, input);
+    const ssrConfigs = await getRollupConfigForSsr(compilation, input);
 
-    if (rollupConfig.input.length > 0) {
-      const bundle = await rollup(rollupConfig);
-      await bundle.write(rollupConfig.output);
+    if (ssrConfigs.length > 0 && ssrConfigs[0].input !== '') {
+      for (const configIndex in ssrConfigs) {
+        const rollupConfig = ssrConfigs[configIndex];
+        const bundle = await rollup(rollupConfig);
+        await bundle.write(rollupConfig.output);
+      }
     }
   }
 }
diff --git a/node_modules/@greenwood/cli/src/lifecycles/serve.js b/node_modules/@greenwood/cli/src/lifecycles/serve.js
index 6787503..a46cf5c 100644
--- a/node_modules/@greenwood/cli/src/lifecycles/serve.js
+++ b/node_modules/@greenwood/cli/src/lifecycles/serve.js
@@ -294,7 +294,7 @@ async function getHybridServer(compilation) {
       const request = transformKoaRequestIntoStandardRequest(url, ctx.request);
 
       if (!config.prerender && matchingRoute.isSSR && !matchingRoute.prerender) {
-        const { handler } = await import(new URL(`./__${matchingRoute.filename}`, outputDir));
+        const { handler } = await import(new URL(`./${matchingRoute.id}.route.js`, outputDir));
         const response = await handler(request, compilation);
 
         ctx.body = Readable.from(response.body);
